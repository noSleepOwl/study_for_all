# 版本控制

#####  关于版本控制的建议参考

>关于版本控制最重要的一点，禁止发布api时不指定版本号
> - api版本必须是强制性的。
> - 通过一个V的前缀来指定版本号，并将其置于URL的最左边，使其它具有最高的作用域（比如，/v1/dogs)。
> - 版本号使用一个简单的有序数，而不要使用点号（如 V1.2)。因为他意味着一种无法兼容原有API版本的粒度--他是一个接口而不是实现。坚持使用V1、V2等
> - 我们应该维护多少个版本？建议至少保持一个旧版本。
> - 一个版本维护多久？在废弃一个版本前给开发人员留有的反应时间至少是一个周期。
> - 有一种强烈的学院派思想就是将格式（XML或JSON) 和版本信息放在头部。其实遵循一些简单的规则就可以：如果你编写的代码处理响应的逻辑有变化，建议直接放到URL中这样很容易看到。如果它不涉及响应逻辑的改变（比如：OAuth响应信息），建议直接放到头部
>
*以上引自《RESTful开发实战》^[1]^*

##### 版本控制的三种模式

1. **不设定版本模式**
	>意味着每个API只提供一个版本，如果要修改本API, 所有的用户都必须使用最新的API，任何API的修改都会影响到所有的用户。

	没有版本控制，API每次更新都会强制调用者更新自己的应用，不利于后期的维护，API升级的成本比较高，升级难度大，如果希望在不影响其他应用的情况下进行升级几乎没有可能。

2. **API自带版本模式**
	>同一个名称的API可以建立多个版本，API调用方根据自己的需求选择使用对应的API版本。新版本与老版本共存，意味着老版本用户不会受新版本更新的影响。

	支持多个版本共存，版本号存在于比较明显的地方，调用者可以很清楚的知道自己目前使用的是那个版本。
3. **兼容版本模式**
	>每个API只有一个版本，API需要兼容以前老版本API的功能。所有版本用户都调用同一个API，通过内在代码保证兼容性。

	兼容之前的版本，在不影响当前调用者使用的情况下进行API的升级和更新，对较大的改动并不支持。

##### 版本控制的实现
我们讨论了关于**API自带版本模式**的实现

**主要的实现方式**

1. **在url中携带版本信息**

    **例如：**
    ```url
    http://localhost:8080/api/v1/test
    ttp://localhost:8080/api/v2/test
    ```


2. **请求参数中带版本号。在每个api请求后携带约定好的version字段信息**

    **例如：**

	```url
    http://localhost:8080/api/test?version=1
    http://localhost:8080/api/test?version=2
	```

3. **通过http头部做指定**

	在处理API请求的时候，服务端根据API调用方在request header中设置自定义的请求头字段`例如：api-version : v1`或者利用`content type`字段，进而执行不同的逻辑处理分支。
    **例如：**
 	```http
 	GET 			http://localhost/api/user/list
	........

	api-version: 	v1
    ```

	content type处理

    ```http
    GET 			http://localhost/api/user/list
    ......
	Accept: 		application/vnd.haveibeenpwned+json

    ```




**其他公司的参照**

 *google 的API 版本控制 详情可以单机此链接进行查看 [Google API Design Guide (谷歌API设计指南)中文版] [googleApiDesign] *

>网络API应该使用语义化的版本。比如给定版本号 MAJOR.MINOR.PATCH：
> 1. 当做出不兼容修改的时候，修改 MAJOR 版本号
> 2. 当以向后兼容的方式添加功能时，修改 MINOR 版本号
> 3. 当进行向后兼容的错误修复时，修改 PATCH 版本号
> 4. 根据 API 版本，指定主要版本号（major version number）时可使用不同的规则：
>		1. 对于 API 第一版（v1），其主要版本号应该编码进 proto 包名称中，例如 google.pubsub.v1。如果包中不含有将来会变化的类型和接口，例如:google.protobuf 和 google.longrunning，则可以从 proto 包中省略主版本号。
>		2.对于v1之外的所有版本的 API，主版本号必须编码进原包名中。例如，google.pubsub.v2。


*github的接口版本控制点击此链接可以查看详情   [github] [github_rest_api]*

Github采用的是第三种方案,在http请求头中包含版本的信息

**三种形式的优劣比较**

| 模式 | 优势 |劣势|
|--------|--------|--------|
|    模式1    |     直接可以在URI中直观的看到API版本，可以直接在浏览器的查看各个版本API的结果.   | 版本号在URI中破坏了REST的[HATEOAS规则]()。版本号和资源之间并无直接关系。|
|    模式2  |     同1   |同1 |
|   模式3    |   遵循了rest的设计风格     |不如url的形式直观 |


# 文档

##### 1. spring-rest-docs
spring-rest-docs是一个**测试**驱动的spring组件，他能生成测试成功的接口进行文档生成，支持markdown的转换或者html的转化，对于文档对接，其实也够了，缺点就是无法像其他工具那样模拟测试数据，前端在对接的时候，可以直接调用模拟数据，尤其对于赶进度的接口，可能是先写接口，再写实现，那么这样的话，就有点不适合。

但他的强大之处，就是可以自动生成文档，而且是经过测试过的接口，减去一些不必要的撰写工作，相对于Swagger来说，没有任何代码的依赖侵入。所以在实际的spring那套开发框架下，还是建议使用，他确实很不错。如果真的需要用到其他系统化的api管理工具，可以把markdown再导入到管理工具中去，即可。

##### 2. RAML
RAML(RESTful API Modeling Language 即 RESTful API 建模语言)是对 RESTful API的一种简单和直接的描述。它是一种让人们易于阅读并且能让机器对特定的文档能解析的语言。RAML 是基于 YAML,能帮助设计 RESTful API 和鼓励对API的发掘和重用,依靠标准和最佳实践从而编写更高质量的API。通过RAML定义,因为机器能够看得懂,所以可以衍生出一些附加的功能服务,像是解析并自动生成对应的客户端调用代码、服务端代码 结构, API说明文档。

1. 设计API。你可以快速的构造你的API，并以人类友好的格式将它呈现出来。它涵盖了一些重要设计的最佳实践，如建模、模式、模板以及代码重用。
2. 构建API。一旦设计好你的API，你就可以借助一些开发工具，将设计好的静态API文档，变成一个服务器端来提供服务。
3. 测试API。引入单元测试可以有效地保证API实现的正确性，你可以通过运行一些脚本来测试你服务端是否涵盖了你设计好的API。
4. 文档化API。Raml可以帮助你脱离同步维护一份额外文档的痛苦。RAML是一门API描述语言，所以你的API一旦被描述，它就是一份现成的API文档。你可以借助一些工具将它生成可视化的文档。
5. 分享以及维护你的API。你可以借助一个基本的JavaScript来生成一些交互式工具（API Consoles或API Nodebooks），这样其他开发者可以使用标准格式与你的维护团队进行交流。

##### 3.Swagger
Swagger与RAML相比，RAML解决的问题是设计阶段的问题，而Swagger则是侧重解决现有API的文档问题，它们最大的不同是RAML需要单独维护一套文档，而Swagger则是通过一套反射机制从代码中生成文档，并且借助ajax可以直接在文档中对API进行交互。因为代码与文档是捆绑的所以在迭代代码的时候，就能方便的将文档也更新了。不会出现随着项目推移代码与文档不匹配的问题。另外Swagger是基于JSON进行文档定义的。

##### 4. API Blueprint
API Blueprint是使用Markdown来定义API的，Markdown相比前面两个RAML、JSON门槛又降低了一大截。同时API Blueprint与前面的Swagger、RAML一样也能提供可视化的文档界面与Mock Server的功能。不过其Mock能力比较弱。


**优劣比较**

| 名称 | 优势 |劣势|
|--------|--------|--|
|   spring-rest-docs     |和spring框架高度集成,在测试的时候即可完成文档的生成,自动生成html可以在项目中嵌入文档供用户远程访问,同时有一定的纠错能力,无代码入侵|无法测试模拟数据,和测试框架绑定,必须有实现才可进行文档的生成,设计阶段不友好  |
|   RAML     |有很多辅助工具可用,友好的mock构建快,体积小,易于阅读        |由于和开发环境格式,在接口版本变动的时候需要额外的进行升级相较与另外两种工具版本的管理有一些难度  |
|   Swagger     |  直接从代码中进行生成方便更新修改,可以在更改接口的同时就可以对其进行更改,动态的生成      |在设计阶段不可用,需要代码的实现来支持文档的生成.  |


# REST 与异步

>**有时**异步可以为REST服务带来更强大的功能，提高服务的性能以及提升用户体验^[2]^
>异步并非一定可以提高性能。异步提高性能的前提是
>1. 任务的执行时间要远大于创建异步线程所消耗的时间。
>2. 服务器资源在同步阻塞情况下是由资源空闲的

##### 异步的实现
**基于HTTP1.1 的技术实现**

1. **Polling**
	即轮询最原始的易行的实现,效率比较低

2. **Comet**
	反向的AJAX ,包括长轮询(Long Polling) 和流(Streaming),
    > 反向AJAX即利用HTTP的keepAlive服务端持续的向客户端发消息,保持请求不中断

    需要第三方库进行支持实现起来比较麻烦
3. **WEBHook**
	客户端在发送请求的时候,将一个回调地址发送给服务器,服务器进行回调,通知客户端任务的进度和处理结果,`微信`的开发中使用过这种技术,还有git一些远程命令中也有此种类似的操作
**基于HTML5规范的实现**

1. **SSE**
	HTML5技术集的一部分,定义了服务器推送技术的标准规范
    >[SSE](http://dev.w3.org/html5/eventsoure)其核心是基于EventSource接口的事件监听机制,包括onopen,onmessage和onerror3个事件监听器.SSE服务器端响应数据的媒体类型(Content-Type)是text/event-stream.

    提供两种模式:
    1. 发布-订阅模式
    2. 广播模式

2. **webSocket**
	消除了HTTP无状态特性的相关限制,功能强大性能突出

**总体比较**

| 名称 | 优点 |缺点|
|--------|--------|--------|
|Polling|客户端可以即时得到服务器的反馈,并且在最终结果之前有机会处理后续的业务,没有注入性污染|浪费宽带,时间间隔参数设置不易把控|
|Comet|异步通信可以在一次请求---响应模型中完成,很好的低延迟性|实现比较复杂,并且客户端和服务端都需要额外的技术实现 |
|WEBHook|易于实现,效率比较高|无法在浏览器作为客户端的环境中使用.存在多线程的问题 |
|SSE|HTML5标准,和编程语言无关|无法在同一条连接上做出第二次请求或者对服务器的响应做出响应,无法支持复杂操作 |
|webSocket|HTML5标准,功能强大性能突出|实现复杂,高性能所带来的资源消耗也是很高的|


# 参考

***

[github_rest_api]: https://developer.github.com/v3/media/#request-specific-version "githubapi版本控制"
[rest_question_url]: http://www.lexicalscope.com/blog/2012/03/12/how-are-rest-apis-versioned/ "rest question"
[spring_url_version_control]: https://www.hifreud.com/2018/01/30/01-API-versioning/ "spring 在url中实现版本控制"
[googleApiDesign]: https://www.bookstack.cn/read/API-design-guide/API-design-guide-12-%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6.md "Google API Design Guide (谷歌API设计指南)中文版 "
[1]《RESTful开发实战》 2.3.3 节 P22
[2] java RESTful Web Service 实战（第2版） P284
